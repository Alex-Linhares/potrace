# Potrace Classes and Data Structures

The Potrace algorithm implementation consists of a carefully designed hierarchy of classes that work together to transform bitmap images into smooth vector curves. The architecture follows a clear separation between public API classes that users interact with and internal data structures that handle the complex mathematical computations during the five-stage processing pipeline. This design allows for clean interfaces while maintaining the computational efficiency required for real-world applications.

## Public API Classes

**Bitmap** serves as the main entry point for users of the Potrace library. This class handles the conversion of various input formats into the internal bitmap representation that the algorithm requires. It accepts numpy arrays, PIL images, and other array-like objects, automatically converting them to the binary format needed for processing. The Bitmap class includes sophisticated preprocessing capabilities, such as automatic thresholding for grayscale images and proper inversion to match the algorithm's expectations. The core functionality is exposed through the trace method, which orchestrates the entire five-stage pipeline and returns a Path object containing the final vector curves. The class also provides configuration options for all major algorithm parameters, including turn policies for resolving ambiguous cases, minimum area thresholds for noise filtering, and curve optimization settings.

**Path** acts as a container for multiple curves that together form a complete vector path. This class inherits from Python's built-in list type, providing familiar iteration and list operations while adding path-specific functionality. The Path class serves as the primary output of the tracing process, encapsulating all the curves generated from a single bitmap. It maintains the hierarchical structure that can represent complex shapes with holes and nested regions, though the full tree structure implementation is reserved for future enhancements. The class provides convenient properties for accessing curves and supports both flat and hierarchical representations of the path data.

**Curve** represents a single closed curve with multiple segments, each of which can be either a straight line or a smooth Bezier curve. This class also inherits from list, allowing easy iteration over the individual segments that make up the curve. Each Curve object contains a complete representation of one traced region from the original bitmap, including both the final processed curve data and access to the original decomposition points for debugging and analysis purposes. The class provides properties for accessing the starting point, segments, and decomposition points, making it easy to work with the curve data in various contexts.

**CornerSegment** and **BezierSegment** represent the two fundamental types of curve segments that can appear in a traced path. CornerSegment handles sharp corners and straight line segments, providing a simple interface for accessing the corner point and end point. BezierSegment manages smooth curve segments with cubic Bezier control points, offering access to both control points and the end point of the curve. Both segment classes implement a common interface through the is_corner property, allowing code to handle both types uniformly while still providing type-specific functionality when needed.

## Internal Data Structures

**opti_t** serves as a specialized container for optimization results during the curve optimization stage. This class holds the penalty values, curve parameters, and control points that result from the complex mathematical calculations involved in combining multiple Bezier segments. The opti_t class encapsulates the results of the optimization process, including the calculated penalty that determines whether a particular combination is acceptable, the control points for the optimized curve, and various mathematical parameters used in the optimization algorithm. This class is essential for the dynamic programming approach used in Stage 5 of the algorithm.

## Internal Processing Classes

**_Curve** represents the internal curve structure used during the processing pipeline. This class contains the raw segment data and processing state that gets transformed through the five stages of the algorithm. The _Curve class maintains an array of _Segment objects and tracks whether the curve has been smoothed, providing the foundation for the curve generation and optimization processes. This internal representation allows for efficient mathematical operations while keeping the complex processing details separate from the clean public API.

**_Path** is the core internal data structure that carries all the information needed throughout the five-stage processing pipeline. This class contains the original path points, area and sign information, and extensive processing data for each stage. The _Path class maintains arrays for longest line calculations from Stage 1, precomputed sums for fast calculations in Stage 2, optimal polygon vertices from Stage 2, and multiple curve representations from Stages 3-5. This comprehensive data structure ensures that all the information needed for each stage is readily available, avoiding the need for expensive recalculations.

**_Point** provides a simple two-dimensional point representation used throughout the algorithm. This class encapsulates x and y coordinates with proper string representation for debugging and development. The _Point class serves as the fundamental geometric primitive for all coordinate calculations, ensuring consistency in how points are handled across the entire codebase. While simple in structure, this class is essential for maintaining the mathematical precision required for accurate curve generation.

**_Segment** represents the internal segment structure that contains all the data needed for both corner and Bezier segments. This class stores the segment type, control points for Bezier curves, vertex information, and various mathematical parameters used during processing. The _Segment class serves as the building block for curve representation, holding the raw data that gets processed and transformed through the algorithm stages. This internal structure allows for efficient mathematical operations while providing the flexibility needed to represent both straight lines and smooth curves.

**_Sums** acts as a container for precomputed sums that enable fast calculations throughout the algorithm. This class holds cumulative sums of coordinates and their products, which are used extensively in the polygon calculation and curve fitting stages. The _Sums class provides the mathematical foundation for the efficient algorithms that make Potrace practical for real-world applications, avoiding the need for expensive recalculations of geometric properties.

## Class Relationships and Design Patterns

The class hierarchy follows a clear separation of concerns, with public API classes providing clean interfaces while internal classes handle the complex mathematical computations. The inheritance from Python's list type in Path and Curve classes provides familiar iteration patterns while adding domain-specific functionality. The internal classes use composition to build complex data structures, with _Path containing arrays of _Point, _Segment, and _Sums objects.

The design employs the Strategy pattern for turn policies, allowing different algorithms to resolve ambiguous cases during path tracing. The Factory pattern is evident in how segment objects are created based on the processing results, with CornerSegment and BezierSegment providing different interfaces for the same underlying data. The Observer pattern is implicit in how the processing stages build upon each other, with each stage transforming the data structures from the previous stage.

Performance considerations are built into the class design, with precomputed sums and efficient data structures that minimize memory allocations and mathematical recalculations. The internal classes are optimized for the specific mathematical operations required by each stage of the algorithm, while the public classes provide convenient interfaces that hide this complexity from users.

Error handling is implemented through exception propagation, with the internal classes focusing on mathematical correctness while the public API classes provide meaningful error messages and validation. The class design supports both the current implementation and future extensions, such as the planned tree structure for hierarchical paths and additional curve optimization algorithms.

The modular design allows for easy testing and debugging, with each class having well-defined responsibilities and clear interfaces. This structure also facilitates future enhancements, such as additional curve types, new optimization algorithms, or support for different input formats. The separation between public and internal classes ensures that users can work with the library without needing to understand the complex mathematical details, while developers can extend and modify the internal implementation as needed. 